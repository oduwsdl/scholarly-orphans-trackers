import uuid
import requests
from datetime import datetime


def make_context():
    """
    Shared context function to be used in an AS2 message

    :return: (dict) the context section of the AS2 message.
    """

    context = ["https://www.w3.org/ns/activitystreams#",
               "http://mementoweb.org/test-ns#"]
    temp = {}
    temp["tracker"] = "http://tracker.mementoweb.org/ns#"
    temp["prov"] = "http://www.w3.org/ns/prov#"
    temp["schema"] = "https://schema.org/"
    temp["prov:used"] = {
        "@type": "@id",
        "@container": "@set"
    }
    temp["prov:wasInformedBy"] = {
        "@type": "@id",
        "@container": "@set"}
    temp["prov:wasGeneratedBy"] = {"@type": "@id"}
    temp["prov:softwareAgent"] = {"@type": "@id"}
    temp["prov:generatedAtTime"] = {
        "@type": "http://www.w3.org/2001/XMLSchema#dateTime"}
    context.append(temp)
    return context


def template_as2(base_event_url: str,
                 tracker_name: str,
                 last_token: str=None
                 ):
    """
    Generates a template as2 to be built off of for each
    tracker.

    :param base_event_url: (str) Base url of event to append event uuid
    :param tracker_name: (str) Tracker name (e.g. github, orcid) in repository
    :return: (dict) as2 template usable by any tracker
    """
    as2_payload = {"@context": {}, "event": {}, "activity": {}}
    as2_payload["@context"] = make_context()

    # Generate hex uuid for given tracker event
    as2_msg_id = uuid.uuid4().hex
    event_id = ""
    if base_event_url.endswith("/"):
        event_id = base_event_url + as2_msg_id
    else:
        event_id = base_event_url + "/" + as2_msg_id
    prov_id = event_id + "#activity"

    prov = {}
    prov["@id"] = prov_id
    prov["type"] = ["prov:Activity", "prov:softwareAgent"]
    prov_used = {}
    prov_used["@id"] = (
        "https://github.com/oduwsdl/scholarly-orphans-trackers"
        "/artifact_tracker/trackers/{}.py"
        .format(tracker_name))
    prov_used["type"] = "schema:SoftwareApplication"
    # provenance_payload["schema:version"] = "v0.3"
    # TODO: To add schema:version consider iterating through list of modules
    # and taking their __version__ variable which could be a string, float,
    # tuple, or None type.
    prov_used["prov:used"] = [
        {
            "id": "https://github.com/pallets/flask/",
            # "schema:version": "1.0.2"
        },
        {
            "id": "http://www.celeryproject.org/",
            # "schema:version": "4.1.1"
        }
    ]
    if last_token:
        prov["tracker:lastToken"] = last_token

    prov["prov:used"] = [prov_used]
    as2_payload["activity"] = prov
    # To be generated by the tracker event
    event_payload = {"type": [], "actor": {},
                     "object": {}, "target": {}}
    event_payload["@id"] = event_id
    event_payload["prov:wasGeneratedBy"] = prov_id
    event_payload["prov:generatedAtTime"] = datetime.now(
    ).strftime("%Y-%m-%dT%H:%M:%SZ")
    event_payload["published"] = ""
    as2_payload["event"] = event_payload

    return as2_payload


def post_to_ldn_inbox(events: iter=None,
                      from_datetime=None,
                      inbox_url=None) -> bool:
    """
    Posts a list of activities to a ldn inbox.

    This is typically used by the trackers (running in different hosts)
    to POST activities to an inbox.

    :param events: (List(dict)) The list of activities as a dict.
    :return: (bool) True if all the events were successfully accepted by
    the inbox. False otherwise.
    """
    from artifact_tracker import tracker_app

    if not hasattr(events, "__iter__"):
        return False

    if not inbox_url:
        return False

    success = True
    event_count = 0
    for event in events:
        if not isinstance(event, dict):
            tracker_app.log.error("The ActivityStream " +
                                  "payload is not of type dict.")
            return False
        # prevent events being posted to inbox if published is earlier than
        # specified from datetime
        start_datetime = tracker_app.app.config.get(
            "DISALLOW_EVENTS_BEFORE") or from_datetime
        if start_datetime:
            start_datetime = datetime.strptime(
                start_datetime, "%Y-%m-%dT%H:%M:%SZ")
            published = event.get("event", {}).get("published")
            published = datetime.strptime(
                published, "%Y-%m-%dT%H:%M:%SZ")
            if published < start_datetime:
                tracker_app.log.debug(
                    "event published datetime earlier allowed datetime.")
                continue

        tracker_app.log.debug("POSTing data to LDN Inbox at: %s"
                              % inbox_url)

        try:
            resp = requests.post(inbox_url,
                                 json=event,
                                 headers={"Content-Type":
                                          "application/ld+json"})
        except (requests.exceptions.ConnectionError,
                requests.exceptions.ConnectTimeout) as e:
            success = False
            tracker_app.log.error(f"Error connecting to LDN inbox: {inbox_url}"
                                  f"\nError: {e}")
            continue

        tracker_app.log.debug(resp.status_code)
        if not resp.status_code >= 200\
                and resp.status_code < 300:
            # TODO: handle error
            tracker_app.log.error("OUTBOX returned non-200 status: %s"
                                  % resp.status_code)
            tracker_app.log.debug(resp.headers)
            tracker_app.log.debug(resp.text)
            success = False
        else:
            event_count += 1

    if event_count > 0:
        return success
    else:
        return False
